////设计小程序来判断当前机器的字节序
//#include<stdio.h>
////int check_sys()
////{
////	int a = 1;
////	char* p = (char*)&a;
////	if (*p == 1)
////		return 1;//小端
////	else
////		return 0;//大端
////}
//int check_sys()
//{
//int a=1;                    //char* p=(char*)&a;
//return (*(char*)&a);        //return (*p);
//}
//int main()
//{
//	//int b = 0x11223344;
//	//占4个字节，大端字节序存储44 33 22 11，小端字节序存储11 22 33 44
//	//大端存储模式：数据的低位保存在内存的高地址中，数据的高位保存在内存的低地址中
//	//小段存储模式：数据的低位保存在内存的低地址中，数据的高位保存在内存的高地址中
//	
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("小端");
//	}
//	else
//	{
//		printf("大端");
//	}
//	return 0;
//}




//#include<stdio.h>
//int check_sys()
//{
//	int i = 1;
//	return *(char*)(&i);
//}
//int main()
//{
//	//int b = 0x11223344;
//	//占4个字节，大端字节序存储44 33 22 11，小端字节序存储11 22 33 44
//	//大端存储模式：数据的低位保存在内存的高地址中，数据的高位保存在内存的低地址中
//	//小段存储模式：数据的低位保存在内存的低地址中，数据的高位保存在内存的高地址中
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("小端");
//	}
//	else
//	{
//		printf("大端");
//	}
//	return 0;
//}



////利用联合体测试当前机器的大小端字节序
//#include<stdio.h>
//int check_sys()
//{
//	struct Stu
//	{
//		int i;
//		char c;
//	}un; 
//	un.i = 1;
//	return un.c;
//}
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("大端");
//	}
//	else
//	{
//		printf("小端");
//	}
//	return 0;
//}



////例题1
//#define _CRT_SECURE_NO_WARNINGS
//#include<stdio.h>
//int main()
//{
//	char a = -1;
//	//10000000000000000000000000000001    -1原码
//	//11111111111111111111111111111111    -1补码
//	signed char b = -1;
//	//10000000000000000000000000000001    -1原码
//	//11111111111111111111111111111111    -1补码
//	unsigned char c = -1;
//	//11111111   -1补码
//	//00000000000000000000000011111111    255         无符号数整型提升前面补0
//	printf("%a=%d,b=%d,c=%d", a, b, c);//-1,-1,255
//	return 0;
//}


////例题2
//#include<stdio.h>
//int main()
//{
//	char a = -128;
//	//10000000000000000000000010000000  整型提升-128
//	//10000000  代表-128  
//	//11111111111111111111111110000000   有符号数整型提升前面补1
//	printf("%u\n", a);  //2的32次方-128  %u打印无符号整数
//	return 0;
//}



////例题3
//#include<stdio.h>
//int main()
//{
//	char a = 128;
//	//00000000000000000000000010000000  整型提升128
//	//10000000  代表-128  
//	//11111111111111111111111110000000   有符号数整型提升前面补1
//	printf("%u\n", a);  //2的32次方-128  %u打印无符号整数
//		return 0;
//	return 0;
//}




////例题4
//#include<stdio.h>
//int main()
//{
//	int i = -20;
//	//-20原码10000000000000000000000000010100
//	//-20补码11111111111111111111111111101100
//	// 10补码00000000000000000000000000001010
//   //相加补码11111111111111111111111111110110
//   //相加原码10000000000000000000000000001010   -10
//	unsigned int j = 10;
//	printf("%d\n", i + j);  //-10
//	return 0;
//}



////例题5
//#include<stdio.h>
//#include<Windows.h>
//int main()
//{
//	unsigned int i;
//	for (i = 9; i <= 0; i++)
//	{
//		printf("%u\n", i); //i总是大于等于0，死循环，i=-0时被认为是unsigned int类型的2^32-1
//		Sleep(1000);
//	}
//	return 0;
//}




////例6
////a是字符型数组，strlen找的是第一次出现尾零（即值为0）的位置。考虑到a[i]其实是字符型，如果要为0，
////则需要 - 1 - i的低八位要是全0，也就是问题简化成了“寻找当 - 1 - i的结果第一次出现低八位全部为0的情况时，
////i的值”（因为字符数组下标为i时第一次出现了尾零，则字符串长度就是i）。只看低八位的话，此时 - 1相当于255，
////所以i == 255的时候， - 1 - i（255 - 255）的低八位全部都是0，也就是当i为255的时候，a[i]第一次为0，所以a[i]的长度就是255了
//#include<stdio.h>
//#include<string.h>
//int main()
//{
//	char a[1000] = { 0 };
//	int i = 0;
//	for (i = 0; i<1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d", strlen(a));//255
//	return 0;
//}





////说明：printf在传入参数的时候如果是整形会默认传入四字节，所以a + b的结果是用一个四字节的整数接收的，
////不会越界。而c已经在c = a + b这一步中丢弃了最高位的1，所以只能是300 - 256得到的44了。
////※由于printf是可变参数的函数，所以后面参数的类型是未知的，所以甭管你传入的是什么类型，
////printf只会根据类型的不同将用两种不同的长度存储。其中8字节的只有long long、float和double（注意float会处理成double再传入），
////其他类型都是4字节。所以虽然a + b的类型是char，实际接收时还是用一个四字节整数接收的。
////另外，读取时，%lld、%llx等整型方式和%f、%lf等浮点型方式读8字节，其他读4字节。
//#include<stdio.h>
//int main()
//{
//	unsigned char a = 200;
//	unsigned char b = 100;
//	unsigned char c = 0;
//	c = a + b;
//	printf("%d %d", a + b, c);//300  44
//	return 0;
//}



////浮点数例题
//#include<stdio.h>
//int main()
//{
//	int n = 9; //整数形式存放
//	float* p = (float*)&n;
//	printf("n的值为：%d\n", n);//9
//	printf("*p的值为：%f\n", *p);//0.000000   浮点数形式取出
//	//将 0x00000009 拆分，得到第一位符号位s = 0，后面8位的指数 E = 00000000 ，
//	//最后23位的有效数字M = 000 0000 0000 0000 0000 1001。
//	//	由于指数E全为0，所以符合上一节的第二种情况。因此，浮点数V就写成：
//	//V=(-1)^0 ×0.00000000000000000001001×2 ^ (-126) = 1.001×2 ^ (-146) 
//	//显然，V是一个很小的接近于0的正数，所以用十进制小数表示就是0.000000。
//
//	*p = 9.0;  //浮点数形式存放
//	printf("num的值为：%d\n", n);//1091567616   整数形式取出
//	//浮点数9.0等于二进制的1001.0，即1.001×2 ^ 3。
//	//9.0 -> 1001.0 ->(-1) ^ 01.0012 ^ 3->s = 0, M = 1.001, E = 3 + 127 = 130
//	//那么，第一位的符号位s = 0，有效数字M等于001后面再加20个0，凑满23位，指数E等于3 + 127 = 130，即
//	//10000010。 所以，写成二进制形式，应该是s + E + M，即
//	//	0 10000010 001 0000 0000 0000 0000 0000
//	printf("*p的值为：%f\n", *p);//9.000000
//	return 0;
//}



